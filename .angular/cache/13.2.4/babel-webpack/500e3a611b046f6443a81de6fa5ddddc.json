{"ast":null,"code":"// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\nconst INDENT_TYPE_SPACE = 'space';\nconst INDENT_TYPE_TAB = 'tab';\n/**\nMake a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\nThe key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\n```\nindents = {\n\tt3: [1, 0],\n\tt4: [1, 5],\n\ts5: [1, 0],\n\ts12: [1, 0],\n}\n```\n*/\n\nfunction makeIndentsMap(string, ignoreSingleSpaces) {\n  const indents = new Map(); // Remember the size of previous line's indentation\n\n  let previousSize = 0;\n  let previousIndentType; // Indents key (ident type + size of the indents/unindents)\n\n  let key;\n\n  for (const line of string.split(/\\n/g)) {\n    if (!line) {\n      // Ignore empty lines\n      continue;\n    }\n\n    let indent;\n    let indentType;\n    let weight;\n    let entry;\n    const matches = line.match(INDENT_REGEX);\n\n    if (matches === null) {\n      previousSize = 0;\n      previousIndentType = '';\n    } else {\n      indent = matches[0].length;\n      indentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB; // Ignore single space unless it's the only indent detected to prevent common false positives\n\n      if (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n        continue;\n      }\n\n      if (indentType !== previousIndentType) {\n        previousSize = 0;\n      }\n\n      previousIndentType = indentType;\n      weight = 0;\n      const indentDifference = indent - previousSize;\n      previousSize = indent; // Previous line have same indent?\n\n      if (indentDifference === 0) {\n        weight++; // We use the key from previous loop\n      } else {\n        const absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n        key = encodeIndentsKey(indentType, absoluteIndentDifference);\n      } // Update the stats\n\n\n      entry = indents.get(key);\n      entry = entry === undefined ? [1, 0] : [++entry[0], entry[1] + weight];\n      indents.set(key, entry);\n    }\n  }\n\n  return indents;\n} // Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\n\n\nfunction encodeIndentsKey(indentType, indentAmount) {\n  const typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n  return typeCharacter + String(indentAmount);\n} // Extract the indent type and amount from a key of the indents Map.\n\n\nfunction decodeIndentsKey(indentsKey) {\n  const keyHasTypeSpace = indentsKey[0] === 's';\n  const type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n  const amount = Number(indentsKey.slice(1));\n  return {\n    type,\n    amount\n  };\n} // Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n// or return undefined if there are no indents.\n\n\nfunction getMostUsedKey(indents) {\n  let result;\n  let maxUsed = 0;\n  let maxWeight = 0;\n\n  for (const [key, [usedCount, weight]] of indents) {\n    if (usedCount > maxUsed || usedCount === maxUsed && weight > maxWeight) {\n      maxUsed = usedCount;\n      maxWeight = weight;\n      result = key;\n    }\n  }\n\n  return result;\n}\n\nfunction makeIndentString(type, amount) {\n  const indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n  return indentCharacter.repeat(amount);\n}\n\nexport default function detectIndent(string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  } // Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n  // If no indents are identified, run again and include all indents for comprehensive detection\n\n\n  let indents = makeIndentsMap(string, true);\n\n  if (indents.size === 0) {\n    indents = makeIndentsMap(string, false);\n  }\n\n  const keyOfMostUsedIndent = getMostUsedKey(indents);\n  let type;\n  let amount = 0;\n  let indent = '';\n\n  if (keyOfMostUsedIndent !== undefined) {\n    ({\n      type,\n      amount\n    } = decodeIndentsKey(keyOfMostUsedIndent));\n    indent = makeIndentString(type, amount);\n  }\n\n  return {\n    amount,\n    type,\n    indent\n  };\n}","map":null,"metadata":{},"sourceType":"module"}